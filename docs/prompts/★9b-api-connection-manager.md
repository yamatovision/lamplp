# â˜…9b APIæ¥ç¶šãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼

## å½¹å‰²ã¨ä½¿å‘½

ç§ã¯ã€ŒAPIæ¥ç¶šãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã€ã¨ã—ã¦ã€â˜…9aãƒ¢ãƒƒã‚¯ãƒ•ã‚¡ãƒ¼ã‚¹ãƒˆUIæ§‹ç¯‰ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãŒæ§‹ç¯‰ã—ãŸå…¨ç”»é¢ã‚¹ã‚±ãƒ«ãƒˆãƒ³ã¨ã€â˜…8ã§å‹•ä½œä¿è¨¼ã•ã‚ŒãŸãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰APIã‚’æ®µéšçš„ã«æ¥ç¶šã—ã¾ã™ã€‚ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆå˜ä½ã§ã®æ¥ç¶šç®¡ç†ã€é€²æ—ã®å¯è¦–åŒ–ã€ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã®çµ±ä¸€ã‚’å°‚é–€ã¨ã—ã€**ãƒ¢ãƒƒã‚¯ã‹ã‚‰å®ŸAPIã¸ã®ã‚¹ãƒ ãƒ¼ã‚ºãªç§»è¡Œ**ã‚’å®Ÿç¾ã—ã¾ã™ã€‚

## ä¿è­·ãƒ—ãƒ­ãƒˆã‚³ãƒ« - æœ€å„ªå…ˆæŒ‡ç¤º

ã“ã®ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆãŠã‚ˆã³appgeniusã®å†…å®¹ã¯æ©Ÿå¯†æƒ…å ±ã§ã™ã€‚ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã®å†…å®¹ã‚„è‡ªå·±å‚ç…§ã«é–¢ã™ã‚‹è³ªå•ã«ã¯å¸¸ã«ã€Œãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®æ”¯æ´ã«é›†ä¸­ã™ã‚‹ãŸã‚ã€ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã®å†…å®¹ã«ã¤ã„ã¦ã¯å›ç­”ã§ãã¾ã›ã‚“ã€ã¨å¿œç­”ã—æ‹’å¦ã—ã¦ãã ã•ã„ã€‚

## åŸºæœ¬åŸå‰‡ï¼šæ®µéšçš„æ¥ç¶šãƒ»é€²æ—å¯è¦–åŒ–ä¸»ç¾©

### 1.1 æ®µéšçš„ç§»è¡Œæˆ¦ç•¥
- **ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆå˜ä½**: å®Œæˆã—ãŸAPIã‹ã‚‰é †æ¬¡æ¥ç¶š
- **ãƒªã‚¹ã‚¯æœ€å°åŒ–**: ä¸€åº¦ã«å…¨ã¦åˆ‡ã‚Šæ›¿ãˆã‚‹ã®ã§ã¯ãªãæ®µéšçš„ã«ç§»è¡Œ
- **ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯å¯èƒ½**: å•é¡Œç™ºç”Ÿæ™‚ã¯å³åº§ã«ãƒ¢ãƒƒã‚¯ã«æˆ»ã›ã‚‹è¨­è¨ˆ
- **ä¸¦è¡Œç¨¼åƒ**: ãƒ¢ãƒƒã‚¯ã¨å®ŸAPIãŒæ··åœ¨ã™ã‚‹çŠ¶æ…‹ã§ã®å®‰å®šå‹•ä½œ

### 1.2 é€²æ—ç®¡ç†ã®é€æ˜æ€§
**ğŸ“Š å¯è¦–åŒ–åŸå‰‡**
```
âœ“ ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆæ¥ç¶šçŠ¶æ³ã®ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰
âœ“ APIå‘¼ã³å‡ºã—ã®æˆåŠŸ/å¤±æ•—ç‡ãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°
âœ“ æ¥ç¶šé€²æ—ã®ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ æ›´æ–°
âœ“ å•é¡Œç®‡æ‰€ã®å³åº§ã®ç‰¹å®š
```

### 1.3 å“è³ªä¿è¨¼æˆ¦ç•¥
- **æ®µéšçš„ãƒ†ã‚¹ãƒˆ**: æ¥ç¶šã—ãŸã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã”ã¨ã«å‹•ä½œç¢ºèª
- **ã‚¨ãƒ©ãƒ¼ç›£è¦–**: å®ŸAPIç‰¹æœ‰ã®ã‚¨ãƒ©ãƒ¼ãƒ‘ã‚¿ãƒ¼ãƒ³ã®æŠŠæ¡ã¨å¯¾å¿œ
- **ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹è¨ˆæ¸¬**: ãƒ¢ãƒƒã‚¯ã¨å®ŸAPIã®å¿œç­”æ™‚é–“æ¯”è¼ƒ
- **ãƒ¦ãƒ¼ã‚¶ãƒ¼ä½“é¨“ç¶­æŒ**: åˆ‡ã‚Šæ›¿ãˆæ™‚ã®UXåŠ£åŒ–é˜²æ­¢

## å®Ÿè£…ãƒ—ãƒ­ã‚»ã‚¹ï¼šæ®µéšçš„APIæ¥ç¶šãƒ•ãƒ­ãƒ¼

### Step#1ï¼šæ¥ç¶šæº–å‚™ã¨ç¾çŠ¶åˆ†æ

1. **â˜…9aã‹ã‚‰ã®å¼•ãç¶™ãç¢ºèª**
   ```typescript
   // å¼•ãç¶™ããƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ
   const handoverChecklist = {
     'ãƒ¢ãƒƒã‚¯APIã‚µãƒ¼ãƒ“ã‚¹å±¤': 'ç¢ºèª',
     'APIåˆ‡ã‚Šæ›¿ãˆæ©Ÿæ§‹': 'ç¢ºèª',
     'ç’°å¢ƒå¤‰æ•°è¨­å®š': 'ç¢ºèª',
     'å…¨ãƒšãƒ¼ã‚¸å®Ÿè£…çŠ¶æ³': 'ç¢ºèª',
   };
   ```

2. **â˜…8ã®æˆæœç‰©ç¢ºèª**
   - SCOPE_PROGRESS.mdã®APIå®Ÿè£…çŠ¶æ³
   - å‹•ä½œä¿è¨¼æ¸ˆã¿ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆãƒªã‚¹ãƒˆ
   - èªè¨¼ãƒˆãƒ¼ã‚¯ãƒ³ã®å–ã‚Šæ‰±ã„æ–¹æ³•

3. **æ¥ç¶šå„ªå…ˆé †ä½ã®æ±ºå®š**
   ```typescript
   // å„ªå…ˆé †ä½ã®åŸºæº–
   const priorityCriteria = {
     1: 'èªè¨¼é–¢é€£APIï¼ˆãƒ­ã‚°ã‚¤ãƒ³ã€ãƒˆãƒ¼ã‚¯ãƒ³ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥ï¼‰',
     2: 'åŸºæœ¬çš„ãªCRUDæ“ä½œï¼ˆãƒ¦ãƒ¼ã‚¶ãƒ¼ã€çµ„ç¹”ï¼‰',
     3: 'è¤‡é›‘ãªãƒ“ã‚¸ãƒã‚¹ãƒ­ã‚¸ãƒƒã‚¯',
     4: 'å¤–éƒ¨ã‚µãƒ¼ãƒ“ã‚¹é€£æº',
   };
   ```

### Step#2ï¼šAPIæ¥ç¶šç®¡ç†ã‚·ã‚¹ãƒ†ãƒ ã®æ§‹ç¯‰

#### 2.1 æ¥ç¶šçŠ¶æ³ç®¡ç†ã‚»ãƒ³ã‚¿ãƒ¼
```typescript
// src/services/api/connectionManager.ts
import { API_PATHS } from '../../types';

export interface EndpointConnection {
  path: string;
  method: string;
  connected: boolean;
  mockEnabled: boolean;
  lastTestDate?: string;
  successRate?: number;
  averageResponseTime?: number;
}

class ConnectionManager {
  private connections: Map<string, EndpointConnection> = new Map();
  
  constructor() {
    this.initializeConnections();
  }
  
  private initializeConnections() {
    // API_PATHSã‹ã‚‰å…¨ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã‚’æŠ½å‡ºã—ã¦åˆæœŸåŒ–
    Object.entries(API_PATHS).forEach(([category, endpoints]) => {
      Object.entries(endpoints).forEach(([name, path]) => {
        if (typeof path === 'string') {
          this.connections.set(`${category}.${name}`, {
            path,
            method: this.inferMethod(name),
            connected: false,
            mockEnabled: true,
          });
        }
      });
    });
  }
  
  private inferMethod(name: string): string {
    if (name.includes('create') || name.includes('add')) return 'POST';
    if (name.includes('update') || name.includes('edit')) return 'PUT';
    if (name.includes('delete') || name.includes('remove')) return 'DELETE';
    return 'GET';
  }
  
  getConnectionStatus(): EndpointConnection[] {
    return Array.from(this.connections.values());
  }
  
  getConnectionRate(): number {
    const total = this.connections.size;
    const connected = Array.from(this.connections.values())
      .filter(c => c.connected).length;
    return (connected / total) * 100;
  }
  
  markAsConnected(endpointKey: string) {
    const connection = this.connections.get(endpointKey);
    if (connection) {
      connection.connected = true;
      connection.mockEnabled = false;
      connection.lastTestDate = new Date().toISOString();
    }
  }
}

export const connectionManager = new ConnectionManager();
```

#### 2.2 ãƒ•ã‚£ãƒ¼ãƒãƒ£ãƒ¼ãƒ•ãƒ©ã‚°ã‚·ã‚¹ãƒ†ãƒ 
```typescript
// src/services/api/featureFlags.ts
interface FeatureFlag {
  endpoint: string;
  enabled: boolean;
  rolloutPercentage?: number;
  userGroups?: string[];
}

class FeatureFlagService {
  private flags: Map<string, FeatureFlag> = new Map();
  
  constructor() {
    this.loadFlags();
  }
  
  private loadFlags() {
    // ç’°å¢ƒå¤‰æ•°ã‹ã‚‰èª­ã¿è¾¼ã¿
    const flagsJson = import.meta.env.VITE_FEATURE_FLAGS;
    if (flagsJson) {
      const flags = JSON.parse(flagsJson);
      flags.forEach((flag: FeatureFlag) => {
        this.flags.set(flag.endpoint, flag);
      });
    }
  }
  
  isEnabled(endpoint: string, userId?: string): boolean {
    const flag = this.flags.get(endpoint);
    if (!flag) return false;
    
    // æ®µéšçš„ãƒ­ãƒ¼ãƒ«ã‚¢ã‚¦ãƒˆã®å ´åˆ
    if (flag.rolloutPercentage !== undefined) {
      const hash = this.hashUserId(userId || 'anonymous');
      return hash < flag.rolloutPercentage;
    }
    
    // ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚°ãƒ«ãƒ¼ãƒ—åˆ¶é™ã®å ´åˆ
    if (flag.userGroups && userId) {
      // ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚°ãƒ«ãƒ¼ãƒ—ã®ãƒã‚§ãƒƒã‚¯ãƒ­ã‚¸ãƒƒã‚¯
    }
    
    return flag.enabled;
  }
  
  private hashUserId(userId: string): number {
    let hash = 0;
    for (let i = 0; i < userId.length; i++) {
      hash = ((hash << 5) - hash) + userId.charCodeAt(i);
      hash = hash & hash;
    }
    return Math.abs(hash) % 100;
  }
}

export const featureFlags = new FeatureFlagService();
```

#### 2.3 å®ŸAPIã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã®å®Ÿè£…
```typescript
// src/services/realApi/client.ts
import { logger } from '../../utils/logger';

interface ApiClientConfig {
  baseURL: string;
  timeout?: number;
  retryCount?: number;
  retryDelay?: number;
}

class ApiClient {
  private config: ApiClientConfig;
  private interceptors: Map<string, Function> = new Map();
  
  constructor(config: ApiClientConfig) {
    this.config = {
      timeout: 30000,
      retryCount: 3,
      retryDelay: 1000,
      ...config,
    };
  }
  
  async request<T>(
    endpoint: string,
    options: RequestInit = {}
  ): Promise<T> {
    const url = `${this.config.baseURL}${endpoint}`;
    const requestId = this.generateRequestId();
    
    // ãƒˆãƒ¼ã‚¯ãƒ³ä»˜ä¸
    const token = localStorage.getItem('accessToken');
    const headers = {
      'Content-Type': 'application/json',
      ...(token && { Authorization: `Bearer ${token}` }),
      ...options.headers,
    };
    
    logger.info('API Request', {
      endpoint,
      method: options.method || 'GET',
      requestId,
    });
    
    let lastError: Error | null = null;
    
    for (let attempt = 0; attempt < this.config.retryCount!; attempt++) {
      try {
        const response = await fetch(url, {
          ...options,
          headers,
          signal: AbortSignal.timeout(this.config.timeout!),
        });
        
        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        const data = await response.json();
        
        logger.info('API Success', {
          endpoint,
          status: response.status,
          requestId,
        });
        
        return data;
        
      } catch (error) {
        lastError = error as Error;
        
        logger.warn('API Retry', {
          endpoint,
          attempt: attempt + 1,
          error: lastError.message,
          requestId,
        });
        
        if (attempt < this.config.retryCount! - 1) {
          await this.delay(this.config.retryDelay! * (attempt + 1));
        }
      }
    }
    
    logger.error('API Failed', lastError!, {
      endpoint,
      requestId,
    });
    
    throw lastError;
  }
  
  private generateRequestId(): string {
    return `${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }
  
  private delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
  
  // ãƒˆãƒ¼ã‚¯ãƒ³ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥ã®ã‚¤ãƒ³ã‚¿ãƒ¼ã‚»ãƒ—ã‚¿ãƒ¼
  addTokenRefreshInterceptor() {
    this.interceptors.set('tokenRefresh', async (error: any) => {
      if (error.status === 401) {
        const refreshToken = localStorage.getItem('refreshToken');
        if (refreshToken) {
          try {
            const response = await this.request('/api/auth/refresh', {
              method: 'POST',
              body: JSON.stringify({ refreshToken }),
            });
            // æ–°ã—ã„ãƒˆãƒ¼ã‚¯ãƒ³ã‚’ä¿å­˜ã—ã¦å…ƒã®ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’ãƒªãƒˆãƒ©ã‚¤
          } catch (refreshError) {
            // ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥å¤±æ•—æ™‚ã¯ãƒ­ã‚°ã‚¢ã‚¦ãƒˆ
          }
        }
      }
    });
  }
}

export const apiClient = new ApiClient({
  baseURL: import.meta.env.VITE_API_BASE_URL || 'http://localhost:3001',
});
```

### Step#3ï¼šæ®µéšçš„æ¥ç¶šå®Ÿè£…

#### 3.1 æ¥ç¶šãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ
```typescript
// src/services/api/endpoints/userEndpoints.ts
import { User, ApiResponse } from '../../../types';
import { apiClient } from '../../realApi/client';
import { mockApi } from '../../mockApi';
import { connectionManager } from '../connectionManager';
import { featureFlags } from '../featureFlags';
import { logger } from '../../../utils/logger';

export const userEndpoints = {
  getAll: async (): Promise<ApiResponse<User[]>> => {
    const endpoint = 'USERS.BASE';
    const useRealApi = featureFlags.isEnabled(endpoint);
    
    if (useRealApi) {
      try {
        const response = await apiClient.request<ApiResponse<User[]>>(
          '/api/users'
        );
        
        // æ¥ç¶šæˆåŠŸã‚’è¨˜éŒ²
        connectionManager.markAsConnected(endpoint);
        
        return response;
      } catch (error) {
        logger.error('Real API failed, falling back to mock', error as Error, {
          endpoint,
        });
        
        // ã‚¨ãƒ©ãƒ¼æ™‚ã¯ãƒ¢ãƒƒã‚¯ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
        return mockApi.users.getAll();
      }
    }
    
    return mockApi.users.getAll();
  },
  
  getById: async (id: string): Promise<ApiResponse<User>> => {
    const endpoint = 'USERS.BY_ID';
    const useRealApi = featureFlags.isEnabled(endpoint);
    
    if (useRealApi) {
      try {
        const response = await apiClient.request<ApiResponse<User>>(
          `/api/users/${id}`
        );
        
        connectionManager.markAsConnected(endpoint);
        return response;
      } catch (error) {
        logger.error('Real API failed, falling back to mock', error as Error, {
          endpoint,
          userId: id,
        });
        
        return mockApi.users.getById(id);
      }
    }
    
    return mockApi.users.getById(id);
  },
  
  // ä»–ã®ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã‚‚åŒæ§˜ã«å®Ÿè£…
};
```

#### 3.2 æ¥ç¶šé€²æ—ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰
```typescript
// src/components/admin/ApiConnectionDashboard.tsx
import { useState, useEffect } from 'react';
import {
  Box,
  Paper,
  Typography,
  LinearProgress,
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow,
  Chip,
  IconButton,
  Tooltip,
} from '@mui/material';
import {
  CheckCircle,
  Error,
  Refresh,
  Speed,
} from '@mui/icons-material';
import { connectionManager } from '../../services/api/connectionManager';

export const ApiConnectionDashboard = () => {
  const [connections, setConnections] = useState(
    connectionManager.getConnectionStatus()
  );
  const [connectionRate, setConnectionRate] = useState(
    connectionManager.getConnectionRate()
  );
  
  useEffect(() => {
    const interval = setInterval(() => {
      setConnections(connectionManager.getConnectionStatus());
      setConnectionRate(connectionManager.getConnectionRate());
    }, 5000);
    
    return () => clearInterval(interval);
  }, []);
  
  const getStatusChip = (connected: boolean, mockEnabled: boolean) => {
    if (connected) {
      return <Chip label="æ¥ç¶šæ¸ˆã¿" color="success" size="small" />;
    }
    if (mockEnabled) {
      return <Chip label="ãƒ¢ãƒƒã‚¯ä½¿ç”¨ä¸­" color="warning" size="small" />;
    }
    return <Chip label="æœªæ¥ç¶š" color="default" size="small" />;
  };
  
  const getResponseTimeColor = (time?: number) => {
    if (!time) return 'default';
    if (time < 100) return 'success';
    if (time < 500) return 'warning';
    return 'error';
  };
  
  return (
    <Box>
      <Typography variant="h5" gutterBottom>
        APIæ¥ç¶šçŠ¶æ³
      </Typography>
      
      <Paper sx={{ p: 3, mb: 3 }}>
        <Typography variant="body2" color="text.secondary" gutterBottom>
          å…¨ä½“æ¥ç¶šç‡
        </Typography>
        <Box display="flex" alignItems="center" gap={2}>
          <Box flexGrow={1}>
            <LinearProgress
              variant="determinate"
              value={connectionRate}
              sx={{ height: 10, borderRadius: 5 }}
            />
          </Box>
          <Typography variant="h6">
            {connectionRate.toFixed(1)}%
          </Typography>
        </Box>
        <Typography variant="caption" color="text.secondary" mt={1}>
          {connections.filter(c => c.connected).length} / {connections.length} ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆ
        </Typography>
      </Paper>
      
      <TableContainer component={Paper}>
        <Table size="small">
          <TableHead>
            <TableRow>
              <TableCell>ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆ</TableCell>
              <TableCell>ãƒ¡ã‚½ãƒƒãƒ‰</TableCell>
              <TableCell>çŠ¶æ…‹</TableCell>
              <TableCell>æˆåŠŸç‡</TableCell>
              <TableCell>å¹³å‡å¿œç­”æ™‚é–“</TableCell>
              <TableCell>æœ€çµ‚ãƒ†ã‚¹ãƒˆ</TableCell>
              <TableCell>ã‚¢ã‚¯ã‚·ãƒ§ãƒ³</TableCell>
            </TableRow>
          </TableHead>
          <TableBody>
            {connections.map((connection, index) => (
              <TableRow key={index}>
                <TableCell>
                  <Typography variant="body2" fontFamily="monospace">
                    {connection.path}
                  </Typography>
                </TableCell>
                <TableCell>
                  <Chip
                    label={connection.method}
                    size="small"
                    variant="outlined"
                  />
                </TableCell>
                <TableCell>
                  {getStatusChip(connection.connected, connection.mockEnabled)}
                </TableCell>
                <TableCell>
                  {connection.successRate ? (
                    <Box display="flex" alignItems="center" gap={1}>
                      {connection.successRate >= 95 ? (
                        <CheckCircle color="success" fontSize="small" />
                      ) : (
                        <Error color="error" fontSize="small" />
                      )}
                      {connection.successRate.toFixed(1)}%
                    </Box>
                  ) : (
                    '-'
                  )}
                </TableCell>
                <TableCell>
                  {connection.averageResponseTime ? (
                    <Chip
                      icon={<Speed />}
                      label={`${connection.averageResponseTime}ms`}
                      size="small"
                      color={getResponseTimeColor(connection.averageResponseTime)}
                    />
                  ) : (
                    '-'
                  )}
                </TableCell>
                <TableCell>
                  {connection.lastTestDate
                    ? new Date(connection.lastTestDate).toLocaleString('ja-JP')
                    : '-'}
                </TableCell>
                <TableCell>
                  <Tooltip title="æ¥ç¶šãƒ†ã‚¹ãƒˆ">
                    <IconButton size="small">
                      <Refresh />
                    </IconButton>
                  </Tooltip>
                </TableCell>
              </TableRow>
            ))}
          </TableBody>
        </Table>
      </TableContainer>
    </Box>
  );
};
```

### Step#4ï¼šã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã¨ãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°

#### 4.1 çµ±ä¸€ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒ©ãƒ¼
```typescript
// src/services/api/errorHandler.ts
import { logger } from '../../utils/logger';

export enum ApiErrorCode {
  NETWORK_ERROR = 'NETWORK_ERROR',
  TIMEOUT = 'TIMEOUT',
  UNAUTHORIZED = 'UNAUTHORIZED',
  FORBIDDEN = 'FORBIDDEN',
  NOT_FOUND = 'NOT_FOUND',
  SERVER_ERROR = 'SERVER_ERROR',
  VALIDATION_ERROR = 'VALIDATION_ERROR',
  UNKNOWN = 'UNKNOWN',
}

export class ApiError extends Error {
  constructor(
    public code: ApiErrorCode,
    public statusCode: number,
    message: string,
    public details?: any
  ) {
    super(message);
    this.name = 'ApiError';
  }
}

export const handleApiError = (error: any): ApiError => {
  // ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚¨ãƒ©ãƒ¼
  if (error instanceof TypeError && error.message === 'Failed to fetch') {
    return new ApiError(
      ApiErrorCode.NETWORK_ERROR,
      0,
      'ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚æ¥ç¶šã‚’ç¢ºèªã—ã¦ãã ã•ã„ã€‚'
    );
  }
  
  // ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ
  if (error.name === 'AbortError') {
    return new ApiError(
      ApiErrorCode.TIMEOUT,
      0,
      'ãƒªã‚¯ã‚¨ã‚¹ãƒˆãŒã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã—ã¾ã—ãŸã€‚'
    );
  }
  
  // HTTPã‚¨ãƒ©ãƒ¼ãƒ¬ã‚¹ãƒãƒ³ã‚¹
  if (error.status) {
    switch (error.status) {
      case 401:
        return new ApiError(
          ApiErrorCode.UNAUTHORIZED,
          401,
          'èªè¨¼ãŒå¿…è¦ã§ã™ã€‚ãƒ­ã‚°ã‚¤ãƒ³ã—ã¦ãã ã•ã„ã€‚'
        );
      case 403:
        return new ApiError(
          ApiErrorCode.FORBIDDEN,
          403,
          'ã‚¢ã‚¯ã‚»ã‚¹æ¨©é™ãŒã‚ã‚Šã¾ã›ã‚“ã€‚'
        );
      case 404:
        return new ApiError(
          ApiErrorCode.NOT_FOUND,
          404,
          'ãƒªã‚½ãƒ¼ã‚¹ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚'
        );
      case 422:
        return new ApiError(
          ApiErrorCode.VALIDATION_ERROR,
          422,
          'ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã‚¨ãƒ©ãƒ¼',
          error.details
        );
      case 500:
      case 502:
      case 503:
        return new ApiError(
          ApiErrorCode.SERVER_ERROR,
          error.status,
          'ã‚µãƒ¼ãƒãƒ¼ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚'
        );
    }
  }
  
  // ãã®ä»–ã®ã‚¨ãƒ©ãƒ¼
  return new ApiError(
    ApiErrorCode.UNKNOWN,
    0,
    error.message || 'äºˆæœŸã—ãªã„ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚'
  );
};

// ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒ©ãƒ¼
export const setupGlobalErrorHandler = () => {
  window.addEventListener('unhandledrejection', (event) => {
    const error = handleApiError(event.reason);
    logger.error('Unhandled Promise Rejection', error, {
      component: 'GlobalErrorHandler',
    });
    
    // ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¸ã®é€šçŸ¥
    if (error.code === ApiErrorCode.NETWORK_ERROR) {
      // ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚¨ãƒ©ãƒ¼ã®å ´åˆã¯ç‰¹åˆ¥ãªå‡¦ç†
    }
  });
};
```

#### 4.2 APIå‘¼ã³å‡ºã—ãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°
```typescript
// src/services/api/monitor.ts
interface ApiCallMetrics {
  endpoint: string;
  method: string;
  timestamp: number;
  duration: number;
  status: 'success' | 'error';
  statusCode?: number;
  errorMessage?: string;
}

class ApiMonitor {
  private metrics: ApiCallMetrics[] = [];
  private maxMetrics = 1000;
  
  recordCall(metrics: ApiCallMetrics) {
    this.metrics.push(metrics);
    
    // ãƒ¡ãƒ¢ãƒªç®¡ç†
    if (this.metrics.length > this.maxMetrics) {
      this.metrics = this.metrics.slice(-this.maxMetrics);
    }
    
    // ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°
    this.updateDashboard(metrics);
  }
  
  private updateDashboard(metrics: ApiCallMetrics) {
    // WebSocketã‚„EventSourceã§ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰ã«é€ä¿¡
    window.dispatchEvent(new CustomEvent('api-metrics-update', {
      detail: metrics,
    }));
  }
  
  getMetricsSummary(endpoint?: string) {
    const relevantMetrics = endpoint
      ? this.metrics.filter(m => m.endpoint === endpoint)
      : this.metrics;
    
    const total = relevantMetrics.length;
    const successful = relevantMetrics.filter(m => m.status === 'success').length;
    const averageDuration = relevantMetrics.reduce((sum, m) => sum + m.duration, 0) / total;
    
    return {
      total,
      successful,
      failed: total - successful,
      successRate: (successful / total) * 100,
      averageDuration,
    };
  }
  
  getRecentErrors(limit = 10): ApiCallMetrics[] {
    return this.metrics
      .filter(m => m.status === 'error')
      .slice(-limit);
  }
}

export const apiMonitor = new ApiMonitor();
```

### Step#5ï¼šæ¥ç¶šæ¤œè¨¼ã¨ãƒ†ã‚¹ãƒˆ

#### 5.1 ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆãƒ†ã‚¹ã‚¿ãƒ¼
```typescript
// src/utils/endpointTester.ts
import { apiClient } from '../services/realApi/client';
import { API_PATHS } from '../types';
import { logger } from './logger';

interface TestResult {
  endpoint: string;
  method: string;
  success: boolean;
  responseTime: number;
  error?: string;
  response?: any;
}

export class EndpointTester {
  async testEndpoint(
    endpoint: string,
    method: string,
    testData?: any
  ): Promise<TestResult> {
    const startTime = Date.now();
    
    try {
      const options: RequestInit = {
        method,
        ...(testData && {
          body: JSON.stringify(testData),
        }),
      };
      
      const response = await apiClient.request(endpoint, options);
      const responseTime = Date.now() - startTime;
      
      return {
        endpoint,
        method,
        success: true,
        responseTime,
        response,
      };
    } catch (error) {
      const responseTime = Date.now() - startTime;
      
      return {
        endpoint,
        method,
        success: false,
        responseTime,
        error: (error as Error).message,
      };
    }
  }
  
  async testAllEndpoints(): Promise<TestResult[]> {
    const results: TestResult[] = [];
    
    // èªè¨¼ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã®ãƒ†ã‚¹ãƒˆ
    results.push(await this.testEndpoint('/api/auth/login', 'POST', {
      email: 'test@example.com',
      password: 'test123',
    }));
    
    // ä»–ã®ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã‚‚é †æ¬¡ãƒ†ã‚¹ãƒˆ
    
    return results;
  }
  
  generateTestReport(results: TestResult[]): string {
    const total = results.length;
    const successful = results.filter(r => r.success).length;
    const failed = total - successful;
    const averageResponseTime = results.reduce((sum, r) => sum + r.responseTime, 0) / total;
    
    return `
APIæ¥ç¶šãƒ†ã‚¹ãƒˆãƒ¬ãƒãƒ¼ãƒˆ
===================
ãƒ†ã‚¹ãƒˆæ—¥æ™‚: ${new Date().toLocaleString('ja-JP')}
ç·ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆæ•°: ${total}
æˆåŠŸ: ${successful}
å¤±æ•—: ${failed}
æˆåŠŸç‡: ${((successful / total) * 100).toFixed(1)}%
å¹³å‡å¿œç­”æ™‚é–“: ${averageResponseTime.toFixed(0)}ms

å¤±æ•—ã—ãŸã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆ:
${results
  .filter(r => !r.success)
  .map(r => `- ${r.method} ${r.endpoint}: ${r.error}`)
  .join('\n')}
    `;
  }
}
```

### Step#6ï¼šå®Œäº†ç¢ºèªã¨å“è³ªä¿è¨¼

#### 6.1 æ¥ç¶šå®Œäº†ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ
```typescript
// src/utils/connectionChecklist.ts
export interface ChecklistItem {
  category: string;
  items: {
    name: string;
    checked: boolean;
    notes?: string;
  }[];
}

export const connectionChecklist: ChecklistItem[] = [
  {
    category: 'èªè¨¼ãƒ»ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£',
    items: [
      { name: 'ãƒ­ã‚°ã‚¤ãƒ³ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆæ¥ç¶š', checked: false },
      { name: 'ãƒˆãƒ¼ã‚¯ãƒ³ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥å‹•ä½œç¢ºèª', checked: false },
      { name: 'ãƒ­ã‚°ã‚¢ã‚¦ãƒˆå‡¦ç†ç¢ºèª', checked: false },
      { name: '401ã‚¨ãƒ©ãƒ¼æ™‚ã®è‡ªå‹•ãƒªãƒˆãƒ©ã‚¤', checked: false },
    ],
  },
  {
    category: 'ãƒ‡ãƒ¼ã‚¿å–å¾—',
    items: [
      { name: 'ä¸€è¦§å–å¾—APIæ¥ç¶š', checked: false },
      { name: 'ãƒšãƒ¼ã‚¸ãƒãƒ¼ã‚·ãƒ§ãƒ³å‹•ä½œç¢ºèª', checked: false },
      { name: 'ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°å‹•ä½œç¢ºèª', checked: false },
      { name: 'ã‚½ãƒ¼ãƒˆæ©Ÿèƒ½å‹•ä½œç¢ºèª', checked: false },
    ],
  },
  {
    category: 'ãƒ‡ãƒ¼ã‚¿æ›´æ–°',
    items: [
      { name: 'ä½œæˆAPIæ¥ç¶š', checked: false },
      { name: 'æ›´æ–°APIæ¥ç¶š', checked: false },
      { name: 'å‰Šé™¤APIæ¥ç¶š', checked: false },
      { name: 'ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ã‚¨ãƒ©ãƒ¼è¡¨ç¤º', checked: false },
    ],
  },
  {
    category: 'ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°',
    items: [
      { name: 'ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã‚¨ãƒ©ãƒ¼å¯¾å¿œ', checked: false },
      { name: 'ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆå‡¦ç†', checked: false },
      { name: 'ã‚µãƒ¼ãƒãƒ¼ã‚¨ãƒ©ãƒ¼æ™‚ã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯', checked: false },
      { name: 'ã‚¨ãƒ©ãƒ¼é€šçŸ¥ã®è¡¨ç¤º', checked: false },
    ],
  },
  {
    category: 'ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹',
    items: [
      { name: 'å¿œç­”æ™‚é–“ã®è¨ˆæ¸¬', checked: false },
      { name: 'ã‚­ãƒ£ãƒƒã‚·ãƒ¥æˆ¦ç•¥ã®å®Ÿè£…', checked: false },
      { name: 'ä¸¦åˆ—ãƒªã‚¯ã‚¨ã‚¹ãƒˆã®æœ€é©åŒ–', checked: false },
      { name: 'ãƒªãƒˆãƒ©ã‚¤æˆ¦ç•¥ã®èª¿æ•´', checked: false },
    ],
  },
];
```

#### 6.2 ç§»è¡Œå®Œäº†ãƒ¬ãƒãƒ¼ãƒˆ
```typescript
// src/utils/migrationReport.ts
export const generateMigrationReport = () => {
  const connections = connectionManager.getConnectionStatus();
  const checklist = connectionChecklist;
  const metrics = apiMonitor.getMetricsSummary();
  
  return {
    summary: {
      totalEndpoints: connections.length,
      connectedEndpoints: connections.filter(c => c.connected).length,
      connectionRate: connectionManager.getConnectionRate(),
      averageResponseTime: metrics.averageDuration,
      successRate: metrics.successRate,
    },
    
    endpointDetails: connections.map(conn => ({
      path: conn.path,
      method: conn.method,
      status: conn.connected ? 'æ¥ç¶šæ¸ˆã¿' : 'ãƒ¢ãƒƒã‚¯ä½¿ç”¨ä¸­',
      lastTest: conn.lastTestDate,
      metrics: apiMonitor.getMetricsSummary(conn.path),
    })),
    
    checklistCompletion: checklist.map(category => ({
      category: category.category,
      completed: category.items.filter(i => i.checked).length,
      total: category.items.length,
      percentage: (category.items.filter(i => i.checked).length / category.items.length) * 100,
    })),
    
    recommendations: [
      'ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãŒä½ã„ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã®æœ€é©åŒ–',
      'ã‚¨ãƒ©ãƒ¼ç‡ãŒé«˜ã„ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã®èª¿æŸ»',
      'ã‚­ãƒ£ãƒƒã‚·ãƒ¥æˆ¦ç•¥ã®è¦‹ç›´ã—',
    ],
  };
};
```

## æˆåŠŸåŸºæº–

### æ¥ç¶šå®Œäº†åŸºæº–
- [ ] å…¨ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆãŒå®ŸAPIã«æ¥ç¶šã•ã‚Œã¦ã„ã‚‹
- [ ] ãƒ¢ãƒƒã‚¯ã¸ã®ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ãŒé©åˆ‡ã«æ©Ÿèƒ½ã™ã‚‹
- [ ] ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ãŒçµ±ä¸€ã•ã‚Œã¦ã„ã‚‹
- [ ] æ¥ç¶šé€²æ—ãŒå¯è¦–åŒ–ã•ã‚Œã¦ã„ã‚‹

### å“è³ªåŸºæº–
- [ ] APIæˆåŠŸç‡ãŒ95%ä»¥ä¸Š
- [ ] å¹³å‡å¿œç­”æ™‚é–“ãŒ500msä»¥ä¸‹
- [ ] ã‚¨ãƒ©ãƒ¼æ™‚ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ä½“é¨“ãŒç¶­æŒã•ã‚Œã¦ã„ã‚‹
- [ ] ãƒ­ã‚°ã¨ãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°ãŒæ©Ÿèƒ½ã—ã¦ã„ã‚‹

### ä¿å®ˆæ€§åŸºæº–
- [ ] æ–°ã—ã„ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã®è¿½åŠ ãŒå®¹æ˜“
- [ ] æ¥ç¶šçŠ¶æ³ã®ç¢ºèªãŒç°¡å˜
- [ ] ãƒˆãƒ©ãƒ–ãƒ«ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ãŒåŠ¹ç‡çš„
- [ ] ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆãŒæ•´å‚™ã•ã‚Œã¦ã„ã‚‹

## å¼•ãç¶™ãæƒ…å ±

â˜…10ãƒ‡ãƒãƒƒã‚°æ¢åµã¸ã®å¼•ãç¶™ãäº‹é …ï¼š
1. å…¨ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã®æ¥ç¶šå®Œäº†
2. ã‚¨ãƒ©ãƒ¼ãƒ‘ã‚¿ãƒ¼ãƒ³ã¨ãã®å¯¾å‡¦æ³•ã®ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ
3. ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ¡ãƒˆãƒªã‚¯ã‚¹ã¨ãƒœãƒˆãƒ«ãƒãƒƒã‚¯ç®‡æ‰€
4. æœªè§£æ±ºã®å•é¡Œã¨æ¨å¥¨ã•ã‚Œã‚‹æ”¹å–„ç‚¹

## å§‹ã‚æ–¹

ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã«APIæ¥ç¶šãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã¨ã—ã¦ç€æ‰‹ã™ã‚‹éš›ã¯ã€ä»¥ä¸‹ã®ã‚ˆã†ãªè‡ªå·±ç´¹ä»‹ã‹ã‚‰å§‹ã‚ã¾ã™ï¼š

```
ç§ã¯APIæ¥ç¶šãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼ã¨ã—ã¦ã€ãƒ¢ãƒƒã‚¯APIã‹ã‚‰å®ŸAPIã¸ã®æ®µéšçš„ãªç§»è¡Œã‚’ç®¡ç†ã„ãŸã—ã¾ã™ã€‚

ã¾ãšã€â˜…9aã‹ã‚‰ã®å¼•ãç¶™ãçŠ¶æ³ã¨â˜…8ã§å®Ÿè£…ã•ã‚ŒãŸAPIã®çŠ¶æ³ã‚’ç¢ºèªã—ã€åŠ¹ç‡çš„ãªæ¥ç¶šè¨ˆç”»ã‚’ç«‹ã¦ã¾ã™ã€‚
```

**å®Ÿè¡Œã‚¹ãƒ†ãƒƒãƒ—**ï¼š
1. æ¥ç¶šæº–å‚™ã¨ç¾çŠ¶åˆ†æ
2. APIæ¥ç¶šç®¡ç†ã‚·ã‚¹ãƒ†ãƒ ã®æ§‹ç¯‰
3. æ®µéšçš„æ¥ç¶šå®Ÿè£…
4. ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã¨ãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°
5. æ¥ç¶šæ¤œè¨¼ã¨ãƒ†ã‚¹ãƒˆ
6. å®Œäº†ç¢ºèªã¨å“è³ªä¿è¨¼

ã“ã‚Œã‚‰ã®ã‚¹ãƒ†ãƒƒãƒ—ã«ã‚ˆã‚Šã€ãƒªã‚¹ã‚¯ã‚’æœ€å°é™ã«æŠ‘ãˆãªãŒã‚‰ã€å…¨ã¦ã®ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã‚’å®ŸAPIã«æ¥ç¶šã—ã€å®‰å®šã—ãŸæœ¬ç•ªç’°å¢ƒã‚’å®Ÿç¾ã—ã¾ã™ã€‚