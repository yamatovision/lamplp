# AIエージェント間通信プロトコル

## 1. 概要

本ドキュメントはAppGeniusプロジェクトにおけるAIエージェント間の情報フローと連携方法を定義します。異なる専門知識を持つAIエージェント間でスムーズな引き継ぎと協働を実現するための標準プロトコルです。

## 2. エージェント連携の基本原則

### 2.1 情報共有の単一の真実源

すべてのエージェント間連携において、以下の情報源を「単一の真実源」として共有します：

- **要件情報**: `requirements.md`
- **現在の実装状況**: `CURRENT_STATUS.md`
- **型定義**: `shared/index.ts`
- **API仕様**: `api/*.md`
- **モックアップ**: `mockups/*.html`

### 2.2 引き継ぎ情報の包括性

エージェント間で作業を引き継ぐ際には、以下の情報を必ず含める必要があります：

1. 作業の現在地点（進捗状況）
2. 完了したタスクと成果物
3. 進行中のタスクと状態
4. 発見された課題や制約条件
5. 次のエージェントに期待されるアクション

### 2.3 段階的詳細化の原則

設計から実装へと進むにつれて、情報は段階的に詳細化されるべきです：

1. 要件定義：高レベルの目標と機能
2. モックアップ：視覚的な表現と動作
3. データモデル・API設計：構造と相互作用
4. 実装タスク：具体的なコード生成ステップ

## 3. フェーズ別エージェント連携プロトコル

### 3.1 設計フェーズの連携

#### 3.1.1 プロジェクトファウンデーション → モックアップクリエイター

**引き継ぎ内容**:
```markdown
## 設計引き継ぎ: プロジェクトファウンデーション → モックアップクリエイター

### 設計方針と要件
- 主要ユースケース: [簡潔な説明]
- ターゲットユーザー: [主要ユーザー層の詳細]
- 核となる機能: [機能リスト]

### 技術スタック制約
- フロントエンド: [技術スタック情報]
- デザインシステム: [デザイン原則と制約]

### モックアップ実装の優先順位
1. [最優先画面]: [理由と重要機能]
2. [次の優先画面]: [理由と重要機能]
...

### 参照ドキュメント
- 要件定義: [requirements.md](/docs/requirements.md)
- 技術制約: [tech-stack.md](/docs/architecture/tech-stack.md)
```

#### 3.1.2 モックアップクリエイター → データモデルアーキテクト

**引き継ぎ内容**:
```markdown
## 設計引き継ぎ: モックアップクリエイター → データモデルアーキテクト

### 完成モックアップ
- 総画面数: [数]
- コア機能モックアップ: [完成率]

### データ構造要件
- 主要データエンティティ: [リストと基本属性]
- データ間関連: [主要な関連性]
- 画面固有のデータ要件: [画面ごとの特殊なデータ要件]

### 注意点とデータ制約
- [特記すべきデータ処理要件]
- [データ量や性能に関する制約]

### 参照ドキュメント
- モックアップ一覧: [mockups/index.html](/mockups/index.html)
- 要件定義: [requirements.md](/docs/requirements.md#data-requirements)
```

#### 3.1.3 データモデルアーキテクト → APIデザイナー

**引き継ぎ内容**:
```markdown
## 設計引き継ぎ: データモデルアーキテクト → APIデザイナー

### 型定義の完成状況
- 型定義ファイル: [shared/index.ts](/shared/index.ts)
- 主要エンティティ型: [型一覧と行番号範囲]

### エンティティ間関連
- [主要な関連と依存関係]

### API設計への影響
- ネスト構造が深いエンティティ: [リストと注意点]
- 大規模データエンティティ: [リストとページネーション要件]
- 頻繁に変更されるエンティティ: [リストと楽観的ロック要件]

### 参照ドキュメント
- 型定義: [shared/index.ts](/shared/index.ts)
- モックアップ: [mockups/*.html](/mockups/)
```

### 3.2 実装フェーズの連携

#### 3.2.1 APIデザイナー → スコーププランナー

**引き継ぎ内容**:
```markdown
## 実装引き継ぎ: APIデザイナー → スコーププランナー

### API仕様の完成状況
- エンドポイント数: [数]
- 認証/認可要件: [詳細]
- エラーハンドリング規約: [詳細]

### 実装の優先順位提案
1. [最優先API]: [理由と依存関係]
2. [次の優先API]: [理由と依存関係]
...

### リスク要因と検討事項
- [性能面での注意点]
- [セキュリティ上の考慮事項]
- [外部依存サービスとの連携]

### 参照ドキュメント
- API仕様書: [api/*.md](/docs/api/)
- 型定義: [shared/index.ts](/shared/index.ts)
```

#### 3.2.2 スコーププランナー → 実装エージェント

**引き継ぎ内容**:
```markdown
## 実装引き継ぎ: スコーププランナー → 実装エージェント(フロントエンド/バックエンド)

### 実装スコープ概要
- スコープID: [ID]
- 機能概要: [簡潔な説明]
- 優先度: [高/中/低]

### タスク分解
- バックエンドタスク: [タスクリスト]
- フロントエンドタスク: [タスクリスト]
- 依存関係グラフ: [タスク間の依存]

### 技術的決定事項
- 状態管理アプローチ: [詳細]
- データ取得戦略: [詳細]
- エラーハンドリング: [詳細]

### 参照ドキュメント
- 実装スコープ: [CURRENT_STATUS.md](/docs/CURRENT_STATUS.md)
- API仕様: [api/*.md](/docs/api/)
- モックアップ: [mockups/*.html](/mockups/)
- 型定義: [shared/index.ts](/shared/index.ts#L100-L200)
```

#### 3.2.3 実装エージェント → テスト&品質エージェント

**引き継ぎ内容**:
```markdown
## 実装引き継ぎ: 実装エージェント → テスト&品質エージェント

### 実装完了機能
- 実装ファイル: [ファイルパスリスト]
- 特筆すべき実装手法: [詳細]
- 既知の制限事項: [詳細]

### テスト対象
- 単体テスト優先事項: [詳細]
- 統合テスト要点: [API連携ポイント]
- エッジケース検証ポイント: [詳細]

### コード品質の注意点
- 複雑性の高い部分: [詳細]
- パフォーマンス最適化ポイント: [詳細]

### 参照ドキュメント
- 実装コード: [パス](/path/to/implementation)
- 型定義: [shared/index.ts](/shared/index.ts)
- CURRENT_STATUS: [CURRENT_STATUS.md](/docs/CURRENT_STATUS.md)
```

### 3.3 デプロイ・メンテナンスフェーズの連携

#### 3.3.1 テスト&品質エージェント → 環境&デプロイエージェント

**引き継ぎ内容**:
```markdown
## デプロイ引き継ぎ: テスト&品質エージェント → 環境&デプロイエージェント

### テスト結果
- パス率: [%]
- 未解決課題: [リスト]
- パフォーマンス測定: [結果サマリー]

### デプロイ要件
- 必要環境変数: [リスト]
- サードパーティ統合: [詳細]
- データマイグレーション要件: [詳細]

### ロールバック計画
- リスク評価: [詳細]
- 監視ポイント: [詳細]

### 参照ドキュメント
- テスト結果: [test-results.md](/docs/testing/test-results.md)
- CURRENT_STATUS: [CURRENT_STATUS.md](/docs/CURRENT_STATUS.md)
```

#### 3.3.2 チェンジディレクター → 関連エージェント

**引き継ぎ内容**:
```markdown
## 変更管理引き継ぎ: チェンジディレクター → 関連エージェント

### 変更要求概要
- 変更ID: [ID]
- 変更種別: [機能追加/バグ修正/リファクタリング]
- 優先度: [高/中/低]

### 影響範囲分析
- 影響コンポーネント: [リスト]
- データモデル変更: [詳細]
- API変更: [詳細]

### 実装アプローチ提案
- 推奨アプローチ: [詳細]
- 代替案と判断理由: [詳細]

### 参照ドキュメント
- 変更要求仕様: [change-request.md](/docs/changes/change-request.md)
- 関連コード: [パス](/path/to/affected/code)
```

## 4. エージェント間の標準引き継ぎフォーマット

すべてのエージェント間引き継ぎは、以下の標準フォーマットに従うべきです：

```markdown
## エージェント引き継ぎ: [送信元エージェント] → [宛先エージェント]

### 1. 作業サマリー
- 作業項目: [完了した作業の簡潔なリスト]
- 進捗: [全体の進捗率]
- 主要成果物: [作成/変更したファイルパス]

### 2. 現在の状態
- 完了タスク: [詳細リスト]
- 進行中タスク: [状態と詳細]
- 未着手タスク: [優先順位付きリスト]

### 3. 発見事項と制約
- 技術的制約: [詳細]
- 課題と対応策: [詳細]
- 保留中の決定事項: [詳細]

### 4. 次のエージェントへの指示
- 優先アクション: [明確な指示]
- 注意点: [特に注意すべき点]
- 期待成果物: [明確な成果物定義]

### 5. 参照情報
- 関連ドキュメント: [リンクリスト]
- コード参照: [リンクリスト]
- 外部参照: [リンクリスト]
```

## 5. フェーズ間の移行判断基準

各フェーズ間の移行は、以下の基準を満たしたときに行われるべきです：

### 5.1 設計 → 実装の移行基準

1. すべてのコア画面のモックアップが完成している
2. データモデルが `shared/index.ts` で型定義されている
3. 主要APIエンドポイントが設計され、ドキュメント化されている
4. `CURRENT_STATUS.md` に最初の実装スコープが定義されている

### 5.2 実装 → デプロイの移行基準

1. 実装スコープのすべてのタスクが完了している
2. 単体テストが実装され、パスしている
3. 統合テストが実装され、パスしている
4. パフォーマンステストが実施され、基準を満たしている
5. セキュリティレビューが完了している

### 5.3 リリース後の継続的改善サイクルの基準

1. ユーザーフィードバックが収集され、分析されている
2. 優先度付けされた変更要求が作成されている
3. 変更の影響範囲が分析されている
4. チェンジディレクターによって変更計画が策定されている

## 6. エージェント間の効率的な情報伝達のためのパターン

### 6.1. リファレンスリンクパターン

コードやドキュメントへの参照は、以下のパターンに従うべきです：

```markdown
[説明テキスト](/絶対パス/ファイル名.拡張子#L開始行-L終了行)
```

例：
```markdown
[User型定義](/shared/index.ts#L50-L70)
```

### 6.2. 決定事項記録パターン

設計または実装中の決定事項は、以下のパターンで記録します：

```markdown
**決定事項**: [簡潔な説明]
- 理由: [決定理由]
- 代替案: [検討した代替案]
- 影響: [決定の影響]
```

### 6.3. 課題提起パターン

解決が必要な課題は、以下のパターンで提起します：

```markdown
**課題**: [簡潔な説明]
- 影響: [課題が解決されない場合の影響]
- 関連コンポーネント: [影響を受けるコンポーネント]
- 推奨アクション: [次のエージェントへの推奨アクション]
```

## 7. エージェント連携の具体例

### 7.1 モックアップからの型定義作成連携

```markdown
## エージェント引き継ぎ: モックアップクリエイター → データモデルアーキテクト

### 1. 作業サマリー
- 完了したモックアップ: ダッシュボード、ユーザー管理、設定画面
- 主要コンポーネント: ナビゲーション、データテーブル、チャート

### 2. 次のステップ
ダッシュボード画面に表示されるデータ構造を型定義する必要があります：
- ユーザーサマリーカード用のUserSummary型
- アクティビティリスト用のActivity型
- チャートデータ用のChartData型

### 3. 注意点
- ダッシュボードは複数のデータソースから情報を集約
- アクティビティは時系列で表示され、無限スクロール対応が必要
- チャートデータは動的にフィルタリング可能にする必要あり

### 4. 参照
- [ダッシュボードモックアップ](/mockups/dashboard.html)
- [データテーブルコンポーネント](/mockups/components/data-table.html)
- [チャートコンポーネント](/mockups/components/chart.html)
```

### 7.2 スコープ計画から実装への連携

```markdown
## エージェント引き継ぎ: スコーププランナー → フロントエンド実装エージェント

### 1. 作業サマリー
- ダッシュボード機能の実装計画を策定
- タスクを3つのフロントエンド実装タスクに分解
- バックエンドタスクとの依存関係を定義

### 2. 実装タスク
優先順位順:
1. ダッシュボードレイアウトコンポーネント実装
2. API連携とデータバインディング実装
3. チャートライブラリ統合とインタラクティブ機能実装

### 3. 技術的注意点
- レスポンシブ対応（モバイル、タブレット、デスクトップ）
- ダークモード対応
- アクセシビリティ（WCAG AA準拠）
- i18n対応（英語、日本語）

### 4. 型定義と共有コンポーネント
- [DashboardProps型](/shared/index.ts#L580-L590)
- [ChartData型](/shared/index.ts#L600-L615)
- [テーブルコンポーネント](/frontend/src/components/Table.tsx)

### 5. 参照情報
- [CURRENT_STATUS.md](/docs/CURRENT_STATUS.md)
- [ダッシュボードAPI仕様](/docs/api/dashboard.md)
- [ダッシュボードモックアップ](/mockups/dashboard.html)
```

## 8. エージェント連携の成功指標

エージェント間連携の成功は、以下の指標で評価できます：

1. **情報伝達の完全性**: 次のエージェントが追加情報なしで作業を開始できる
2. **作業の無駄の最小化**: 重複作業や反復的な問い合わせが発生しない
3. **成果物の一貫性**: 各エージェントの成果物が整合性を保つ
4. **移行時間の短縮**: エージェント間の引き継ぎにかかる時間が最小限
5. **決定事項の追跡可能性**: なぜその決定が行われたかが明確に記録されている

## 9. エージェント連携プロトコルの継続的改善

本プロトコルは以下のイベントで見直しと更新を行います：

1. 新しいエージェント種別の追加時
2. エージェント間連携に問題が発生した場合
3. プロジェクトフェーズの完了時
4. 主要な技術スタックの変更時

改善提案は `agent-communication-protocol.md` への更新という形で提出し、全エージェントに周知すべきです。

## 10. まとめ

効果的なエージェント間連携は、プロジェクトの成功に不可欠です。明確な引き継ぎプロトコルと標準化された情報交換フォーマットは、異なる専門性を持つAIエージェント間のシームレスな協働を実現します。

このプロトコルに従うことで、情報の欠落や誤解を最小限に抑え、効率的なプロジェクト進行を促進します。